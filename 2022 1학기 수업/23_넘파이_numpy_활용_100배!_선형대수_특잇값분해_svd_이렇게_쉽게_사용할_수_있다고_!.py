# -*- coding: utf-8 -*-
"""23.넘파이 NumPy 활용 100배! 선형대수 특잇값분해 SVD 이렇게 쉽게 사용할 수 있다고?!.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bSk4FvMmsyuv6v-6JynmyWZT6HUNCSNQ

# 23.넘파이 NumPy 활용 100배! 선형대수 특잇값분해 SVD 이렇게 쉽게 사용할 수 있다고?!

SVD(Singular Value Decomposition)
"""

# Commented out IPython magic to ensure Python compatibility.
from scipy import misc
img = misc.face()
import matplotlib.pyplot as plt
# %matplotlib inline

img_array = img / 255
img_array

img_gray = img_array @ [0.2126, 0.7152, 0.0722]
img_gray

img_gray.shape

from numpy import linalg
U, s, Vt = linalg.svd(img_gray) #linalg 선형대수 모듈, U, s, Vt 로 특잇값을 분해 했다. 
U.shape, s.shape, Vt.shape

s @ Vt

import numpy as np
Sigma = np.zeros((U.shape[1], Vt.shape[0]))
np.fill_diagonal(Sigma, s) # 대각 행열을 만들어 주었다.

Sigma

Sigma @ Vt

linalg.norm(img_gray - U @ Sigma @ Vt) # 원래 값과 이미지변환의 값이 얼마나 비슷하나

np.allclose(img_gray, U @ Sigma @ Vt)

plt.plot(s)
plt.show() # 원본값을 시각화 해보기

k = 400
approx = U @ Sigma[:, :k] @ Vt[:k, :] # 일부값만 슬라이싱해서 가지고 왔다. 
plt.imshow(approx, cmap = 'gray')

img_array.shape

img_array_transposed = np.transpose(img_array, (2, 0, 1))
img_array_transposed.shape # RGB 3개의 채널이 가장 앞쪽에 왔다.

U, s, Vt = linalg.svd(img_array_transposed)
U.shape, st.shape, Vt.shape

Sigma = np.zeros((3, 768, 1024))
for j in range(3):
    np.fill_diagonal(Sigma[j, :, :], s[j, :])

reconstructed = U @ Sigma @ Vt # 원본값 복원

reconstructed.shape # 원본이미지와 같지 않다.

reconstructed.min(), reconstructed.max()

reconstructed = np.clip(reconstructed, 0, 1) # 최솟값을 0, 최댓값을 1로 만들어 준다.
reconstructed.min(), reconstructed.max()

plt.imshow(np.transpose(reconstructed, (1, 2, 0)))
plt.show() #채널이 맨 뒤로 가게 만들어 주었다.